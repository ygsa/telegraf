#!/usr/bin/env perl
=head1 NAME

  telegraf-discover - discover db process and change telegraf configure file

=cut

=head1

  use telegraf-discover --help for more info.
  options:
    conf:    telegraf configure file, default is 
                /etc/telegraf/telegraf.conf;
    confd:   telegraf configure directory, default is
                /etc/telegraf/telegraf.d;
    disf:    ini style configure file to store db user and pass, 
                default is /etc/telegraf/discover.conf;
    update:  whether generate sub configure file or not,
                default is /etc/telegraf/telegraf.d/<db>-auto.conf;
    server:  consul server to get needed message;
    jitter:  random sleep before request consul api;
    verbose: print more messages.


    the sample of the `disf` file, multiple database maybe running in 
    one host, we'll inherit default pass if not set instance pass:

      # /etc/telegraf/discover.conf
      [mysql]
      user=monitor  # can not change by instance
      pass=xxxxxx   # default pass
      3306=111111   # pass for 3306 port
      3307=222222   # pass for 3307 port
      ignore=3301,3303 # ignore 3301 and 3303 port

      [postgresql]
      is_local=1
      user=postgres

      [redis]
      pass=xxxxx # default pass
      6379=xxxxx    # pass for 6379 port

      [memcached]
      ignore=11212

      [dns_query]
      ignore = 0
      domains = www.baidu.com

      [megacli]
      ignore = 0   # enable megacli monitor

      [iptables]
      ignore = 0   # enable iptables monitor

     Note: 
       Currently only the following types are supported:
          memcached, mysql, mongodb, redis, pika, iptables

       telegraf-discover will read disf from consul preferrentially.
=cut

use strict;
use warnings;
use POSIX qw(strftime);
use Getopt::Long;
use Carp;

BEGIN {
   $INC{$_} = __FILE__ for map { (my $pkg = "$_.pm") =~ s!::!/!g; $pkg } (qw(
      Utils
      Disconf
      Consul
      JSONTiny
   ));
}

# force flush
$| = 1;

my($update,$verbose,$help);
my $conf    = "/etc/telegraf/telegraf.conf";
my $confd   = "/etc/telegraf/telegraf.d";
my $default = "/etc/default/telegraf";
my $disf  = "/etc/telegraf/discover.conf";
my $sock  = "/var/log/telegraf/telegraf.sock";
my $token = "";
my $server;
my $scheme;
my $jitter= 5; # sleep random seconds

GetOptions(
  "conf=s"    => \$conf,
  "confd=s"   => \$confd,
  "default=s" => \$default,
  "update!"   => \$update,
  "token=s"   => \$token,
  "server=s@" => \$server,
  "scheme=s"  => \$scheme,
  "jitter=i"  => \$jitter,
  "verbose!"  => \$verbose,
  "help|h"    => \$help,
) or die "error:$!";

if ($help) {
  usage($0);
}

sub usage {
  my $name = shift;
  system("perldoc -T $name");
  exit 0;
}

open my $fp, "<", $0
     or warn "open $0 error: $!";

unless (defined $fp) {
  Utils::time_print("fp error, exit ...");
  exit 1;
}

# exit if flock error
unless (flock($fp, 2|4)) {
  Utils::time_print("cann't get flock, exit...");
  exit 1;
}

# random sleep to avoid make too stress to consul
if (defined $jitter && $jitter > 0) {
  sleep(int(rand($jitter)));
}

# option always prefer default config
my $default_meta = Utils::get_default_meta($default);
$token  ||= $default_meta->{token};
$server ||= $default_meta->{server} || ["localhost:8500"];
$scheme ||= $default_meta->{scheme} || 'http';

my $consul = Consul->new(
    conf    => $conf,
    confd   => $confd,
    default => $default,
    servers => $server,
    sockfile=> $sock,
    token   => $token,
    scheme  => $scheme,
    update  => $update,
    timeout => 3,
  );

## check consul handle
#croak "consul new error" unless defined $consul;

# skip consul when set ID and IP
if (defined $default_meta->{id} and defined $default_meta->{ip}) {
  Utils::time_print("disable consul feature...");
  $consul = undef;
}

# skip consul when set disable_consul
if (defined $default_meta->{disable_consul} and $default_meta->{disable_consul} == 1) {
  Utils::time_print("disable consul feature...");
  $consul = undef;
}

my $discover = '';
my $force_overwrite = 0;
if (defined $consul) {
  # check consul server is ok
  croak "no alive consul server, will exit..." unless defined $consul->{servers};

  my $result = $consul->get_key_from_consul({ tag => 'discover' }, 0);

  # prepare consul key value
  $discover = $result->{value} || '';
  $consul->send_custom_to_graphite('telegraf_consul.status', $result->{status});

  Utils::create_dir_if("$confd") 
      or croak "create $confd error and $confd is not exist";

  if (length($discover) > 0 && -e $disf) {
    my $crc_file = Utils::file_crc32($disf) || 'NULL';
    my $crc_disc = Utils::string_crc32($discover);
    if ($crc_file ne $crc_disc) {
      $force_overwrite = 1;
      print "overwrite $disf error!" unless Utils::write_file($disf, $discover);
    }
  }
}
else {
  $discover = Utils::read_cfg($disf);
}

my $disconf = Disconf->new( (update => $update, force => $force_overwrite) );
my $results = $disconf->get_server_list();
my $sects   = Utils::parsecfg($discover);
$| = 1; # enforce flush for print

unless (defined $results) {
  Utils::time_print("error - cann't get listen port lists, exit ...");
  exit 1;
}

my $is_trigger = 0;

# ensure telegraf process is running, conf maybe changed 
# but not restart service
my $is_alive = $disconf->is_telegraf_alive();
if ($is_alive) {
  Utils::time_print("ok - telegraf is running");
  if ($disconf->is_telegraf_conf_change($conf)) {
    Utils::time_print("warn - conf was changed but not restart telegraf!");
    $is_trigger++;
  }

  # detect graphite connection, 
  # telegraf maybe produce many warning log
  if ($disconf->is_graphite_connection_abnormal($conf)) {
    Utils::time_print("warn - graphite connection abnormal, restart telegraf!");
    $is_trigger++;
  }

}
else {
  Utils::time_print("error - telegraf is not running");
}

# detect and generate sub conf file for listen service
foreach my $type (keys %{$results->{listen}}) {
  next unless $disconf->is_support($type);

  my $i = $disconf->gen_conf_for_listen(
            $confd, $type,
            $results->{listen}->{$type}, 
            $sects->{$type},
          );
  $is_trigger += $i;
}

# detect and generate sub conf file for non_listen service
foreach my $type (keys %{$results->{non_listen}}) {
  next unless $disconf->is_support($type);

  my $i = $disconf->gen_conf_for_non_listen(
            $confd, $type,
            $sects->{$type},
  );

  $is_trigger += $i;
}

# detect and generate sub conf file for one_enable service
foreach my $type (keys %{$results->{one_enable}}) {
  next unless $disconf->is_support($type);

  my $i = $disconf->gen_conf_for_one_enable(
            $confd, $type,
            $sects->{$type},
  );

  $is_trigger += $i;
}

# consul discover
if (defined $consul) {
  $is_trigger += $consul->make_consul_discover();
}

# should restart telegraf service
if ($is_trigger > 0) {
  Utils::time_print("need restart telegraf") if $verbose;
  if ($update) {
    unless (is_telegraf_conf_ok()) {
      Utils::time_print("error - telegraf --test error, check the config syntax");
      $consul->send_custom_to_graphite('telegraf_restart.status', 2) if defined $consul;
      exit 1;
    }  
    my $cmd = "service telegraf restart";
    my($high, $low) = Utils::exec_system("$cmd");
    sleep 1; # wait a moment

    if ($high != 0 || $low != 0) {
      Utils::time_print("error - $cmd execute error! high: $high, low: $low");
      $consul->send_custom_to_graphite('telegraf_restart.status', 0) if defined $consul;
    }
    else {
      if ($disconf->is_telegraf_alive()) {
        Utils::time_print("ok - $cmd execute ok, and process is running!");
        $consul->send_custom_to_graphite('telegraf_restart.status', 1) if defined $consul;
      }
      else {
        Utils::time_print("error - $cmd execute ok, but process is not running!");
        $consul->send_custom_to_graphite('telegraf_restart.status', 0) if defined $consul;
      }
    }
  }
}

sub _get_user_id {
  my $user  = shift;
  my $group = shift;

  my $uid = getpwnam($user) || 0;
  my $gid = getgrnam($group) || 0;

  return ($uid, $gid);
}

sub is_telegraf_conf_ok {
  my $status = 0;
  my $cmd = "telegraf --test  --config /etc/telegraf/telegraf.conf >/dev/null 2>&1";
  my($high, $low) = Utils::exec_system("$cmd");
  if ($high != 0 || $low != 0) {
    $status = 0;
  }
  else {
    $status = 1;
  }

  # change telegraf.log permission
  my ($uid, $gid) = _get_user_id("telegraf", "telegraf");
  my $logfile = "/var/log/telegraf/telegraf.log";
  if (-e $logfile) {
    chown($uid, $gid, $logfile) or Utils::time_print("warn - change $logfile permission error!");
  }

  return $status;
}

=head1 AUTHOR

zhe.chen <chenzhe07@gmail.com>

=head1 CHANGELOG

v0.1.0 version

=cut

# ####################################################################
# Utils packages
# ####################################################################
package Utils;
# common utils methods
# <chenzhe07@gmail.com>
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use POSIX qw(strftime);
use File::Path;
use File::Find;
use File::Basename;
use Sys::Hostname;
use IO::Socket::INET;
use JSONTiny;
use MIME::Base64;
use Carp;

use vars qw($VERSION);
our $VERSION = '0.10';

sub create_dir_if {
  my $dir  = shift;
  if (!-d $dir) {
    eval {
      mkpath($dir);
    };
    if ($@) {
      my $e = $@;
      undef $@;
      unless (-d $dir) {
        carp "failed to create dir:$dir:$e";
        return 0;
      }
    }
  }
  return 1;
}

sub create_cnf_if {
  my $cnf   = shift;
  my $res   = shift;
  my $force = shift || 0;

  if (-e $cnf && !$force) {
    return 0;
  }

  unless (defined $res) {
    if ($force) {
      $res = "";
    }
    else {
      time_print("ignore $cnf, as empty content!");
      return 0;
    }
  }

  if (Utils::file_crc32($cnf) eq Utils::string_crc32($res)) {
    Utils::time_print("skip to write as there is no change in the content and source file!");
    return 0;
  }

  # write res to cnf
  open my $fh, '>', $cnf or carp "open $cnf error: $!";
  return 0 unless defined $fh;

  flock($fh, 2) or return 0;

  eval {
    print $fh $res;
  };
  if ($@) {
    carp "write $cnf error: $@";
    return 0;
  }

  flock($fh, 8) or carp "unlock $cnf error: $!";
  close $fh;

  return 1;
}

sub is_dir_empty {
  my $dir = shift;
  return 0 unless -d $dir;
  opendir (my $dh, $dir) or carp "failed to open $dir";

  my $num = 0;

  eval {
    READ: while (my $name = readdir($dh)) {
      $num++ if $name ne "." && $name ne "..";
      # should be skip if has file
      last READ if $num > 0;
    }
  };
  if ($@) {
    $num = 99; # unknown error
  }
  return $num == 0;
}

sub exec_system {
  my $cmd     = shift;
  my $log_out = shift;

  if ($log_out) {
    return  system_rc(system("$cmd >> $log_out 2>&1"));
  }
  else {
    return system_rc(system($cmd));
  }
}

sub exec_cmd_return {
  my $cmd  = shift;
  my $res;
  eval {
    $res = `$cmd`;
  };
  if ($@) {
    return "Err: $@";
  }
  chomp($res);
  return $res;
}

sub system_rc {
  my $rc   = shift;
  my $high = $rc >> 8;
  my $low  = $rc & 255;
  return ($high, $low);
}

sub is_tcp_port_open {
  my $host = shift;
  my $port = shift;

  my $fail = 0;
  my $socket = IO::Socket::INET->new(
    PeerAddr => $host,
    PeerPort => $port,
    Proto    => "TCP",
    Timeout  => 2
  ) || $fail++;

  if ($fail == 0) {
    close $socket;
    return 1;
  }
  return 0;
}

# remove prefix and suffix quote
sub remove_psquote {
  my $msg = shift;
  return undef unless defined $msg;
  $msg =~ s/^(?:"|')|(?:"|')$//g;
  return $msg;
}

my @shell_escape_chars = (
  '"', '`', '\x27',
);

sub unescape_for_shell {
  my $str = shift;
  if ( !index( $str, '\\\\' ) ) {
    return $str;
  }
  foreach my $c (@shell_escape_chars) {
    my $x       = quotemeta($c);
    my $pattern = "\\\\(" . $x . ")";
    $str =~ s/$pattern/$1/g;
  }
  return $str;
}

sub escape_for_shell {
  my $str = shift;
  my $ret = "";
  foreach my $c ( split //, $str ) {
    my $x      = $c;
    my $escape = 0;
    foreach my $e (@shell_escape_chars) {
      if ( $e eq $x ) {
        $escape = 1;
        last;
      }
    }
    if ( $x eq "'" ) {
      $x =~ s/'/'\\''/;
    }
    if ( $x eq "\\" ) {
      $x = "\\\\";
    }
    if ($escape) {
      $x = "\\" . $x;
    }
    $ret .= "$x";
  }
  return $ret;
}

sub fuzzy_path {
  my $cmd = shift;
  $cmd =~ s/ /\ /gi;
  $cmd =~ s#//#/#gi;
  return $cmd;
}

sub get_dir_size {
  my $dir = shift;
  return 0 unless -d $dir;
  my $size = 0;
  find(sub { $size += -s if -f $_ }, $dir);
  return $size;
}

sub get_confd_list {
  my $dir = shift;
  $dir = dirname($dir) if -f $dir;
  return undef unless -d $dir;

  my @lists;
  find(
   sub {
     return unless -f;
     return unless /\.(?:cnf|conf|json|ini|yaml)$/i;
     push @lists, $File::Find::name;
   }, 
   $dir
  );
  return @lists;
}

sub _parse_server {
  my $line  = shift;
  my ($res) = ($line =~ /servers\s*=\s*\[(.+)\]/i);

  return undef unless defined $res;
  my @servers;
  foreach my $k (split(/,\s*/, $res)) {
    $k =~ s/'|"//g;
    push @servers, $k;
  }

  return @servers;
}

sub get_conf_servers {
  my $keys = shift;
  my $conf = shift;
  return undef unless -e $conf;

  my @servers;
  my $seen = 0;
  open my $cfg, '<', $conf or croak "open $conf error: $!";
  while (<$cfg>) {
    chomp;
    next if $_ =~ /^\s*#/;

    if ($_ =~ /^\s*\[/) {
      if ($_ =~ /$keys/) {
        $seen = 1;
      }
      else {
        $seen = 0;
      }
    }

    if ($seen == 1 && $_ =~ /^\s*servers/) {
      @servers = _parse_server($_);
      last;
    }
  }

  return @servers;
}

sub current_time {
  my $zone = shift || "Asia/Shanghai";
  local $ENV{TZ} = "$zone" if defined $zone;
  return strftime("%Y-%m-%d 00:00:00", localtime(time));
}

sub time_print {
  my $msg  = shift;

  my $timestr = 
        strftime("%Y-%m-%d %H:%M:%S", localtime(time));

  foreach my $k (split(/\n/, $msg)) {
    next if $k eq '';
    print "[$timestr] $k\n";
  }
}

sub file_crc32 {
  my ($file,  $init_value, $polynomial) = @_;

  my $input = read_cfg($file);
  return string_crc32($input, $init_value, $polynomial);
}

sub string_crc32 {
 my ($input, $init_value, $polynomial) = @_;

 return undef unless defined $input;
 $init_value = 0 unless (defined $init_value);
 $polynomial = 0xedb88320 unless (defined $polynomial);

 my @lookup_table;

 for (my $i=0; $i<256; $i++) {
   my $x = $i;
   for (my $j=0; $j<8; $j++) {
     if ($x & 1) {
       $x = ($x >> 1) ^ $polynomial;
     } else {
       $x = $x >> 1;
     }
   }
   push @lookup_table, $x;
 }

 my $crc = $init_value ^ 0xffffffff;

 foreach my $x (unpack ('C*', $input)) {
   $crc = (($crc >> 8) & 0xffffff) ^ $lookup_table[ ($crc ^ $x) & 0xff ];
 }

 $crc = $crc ^ 0xffffffff;

 return $crc;
}

sub read_cfg {
  my $file = shift;
  unless (-f $file) {
    time_print("no file or file is not exist");
    return undef;
  }

  # slurp in the file
  local $/ = undef;
  open CFG, '<', $file or croak "open $file error: $!";
  my $contents = <CFG>;
  close CFG;

  return $contents;
}

sub parsecfg {
  my $contents = shift;

  return _read_string($contents);
}

sub parsecfg_file {
  my $file = shift;
  return undef unless -r $file;

  my $err;
  open my $fh, '<', $file or $err = "$!";

  if (defined $err) {
    time_print("parsecfg_file $file err: $err");
    return undef;
  }

  my $contents = join('', <$fh>);
  close $fh;

  return _read_string($contents);
}

sub _read_string {
  return undef unless defined $_[0];

  # Parse the file
  my %outs;
  my $ns      = '_';
  my $counter = 0;
  foreach (split /(?:\015{1,2}\012|\015|\012)/, shift) {
    $counter++;

    # Skip comments and empty lines
    next if /^\s*(?:\#|\;|$)/;

    # Remove inline comments
    s/\s\;\s.+$//g;

    # Handle section headers
    if ( /^\[\s*(.+?)\s*\]\s*$/ ) {
      # Create the sub-hash if it doesn't exist.
      # Without this sections without keys will not
      # appear at all in the completed struct.
      $outs{$ns = $1} ||= {};
      next;
    }

    # Handle properties
    if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
      $outs{$ns}->{$1} = $2;
      next;
    }
  }
  return \%outs;
}

sub splitcfg_file {
  my $file = shift;
  return undef unless -r $file;

  my $err;
  open my $fh, '<', $file or $err = "$!";

  if (defined $err) {
    time_print("parsecfg_file $file err: $err");
    return undef;
  }

  my $contents = '';
  while(<$fh>) {
    next if /^(?:\#|\;)/;
    $contents .= $_;
  }
  close $fh;

  return _split_string($contents);
}

sub _split_string {
  return undef unless defined $_[0];

  my $content = shift;
  my @results = split(/(?:\015{1,2}\012|\015|\012)(?=\[{1,})/, $content);

  my %outs;

  foreach my $sec (@results) {
    next if $sec eq '';

    my $res  = _return_string($sec);
    foreach my $k (keys %$res) {
      $outs{sections}{$k}{content} = [] unless defined $outs{sections}{$k}{content};
      $outs{fields} = [] unless defined $outs{fields};
      push @{$outs{sections}{$k}{content}}, $res->{$k};
      push @{$outs{fields}}, "$k";
    }
  }

  return \%outs;
}

sub _return_string {
  return undef unless defined $_[0];
  return undef if $_[0] eq '';

  my %outs;
  my $ns = '_';
  my $counter = 0;

  foreach (split /(?:\015{1,2}\012|\015|\012)/, shift) {
    $counter++;

    # Just skip begin comments
    next if /^(?:\#|\;)/;

    # Handle section headers
    if ( /^\[\s*(.+?)\s*\]\s*$/ ) {
      $outs{$ns = $1} ||= '';
      next;
    }

    # Handle section string
    if (/.*/) {
      $outs{$ns} .= "$_\n";
      next;
    }
  }

  return \%outs;
}

sub _default_server_value {
  my $v = shift;

  my @k = split(/,\s*/, $v);
  return \@k;
}

sub get_default_meta {
  my $conf = shift || '/etc/default/telegraf';

  my $err;
  open my $fh, '<', $conf or $err = "$!";

  unless (defined $fh) {
     time_print("open $conf error: $err");
     return undef;
  };

  my %meta;
  $meta{host} = hostname();
  while(<$fh>) {
    chomp;
    s/(?:\x{22}|\x{27})//g;

    my ($t, $v) = split(/\s*=\s*/, $_, 2);
    if ($t =~ /^server$/i) {
      $meta{lc($t)} = _default_server_value($v);
    }
    else {
      $meta{lc($t)} = $v;
    }
  }

  close $fh;

  return \%meta;
}

sub write_file {
  my ($file, $content) = @_;

  return 0 unless defined $content;
  open my $fh, '>', $file
     or warn "open $file error: $!";

  return 0 unless defined $fh;

  print $fh $content;
  close($fh);

  return 1;
}

1;

# ########################################################
# Consul packages
# #######################################################
package Consul;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use List::Util qw(shuffle);
use File::Copy qw(copy);
use File::Basename;
use Utils;
use MIME::Base64;
use JSONTiny;
use IO::Socket::UNIX;

sub new {
  my ($class, %args) = @_;
  my $self = {};

  $self->{conf}    = $args{conf} || '/etc/telegraf/telegraf.conf';
  $self->{confd}   = $args{confd} || '/etc/telegraf/telegraf.d';
  $self->{bakdir}  = $args{bakdir} || '/etc/telegraf/backup_confd';
  $self->{default} = $args{default} || '/etc/default/telegraf';
  $self->{servers} = _get_alive_server($args{servers}) || undef;
  $self->{token}   = $args{token} || '';
  $self->{scheme}  = $args{scheme} || 'http';
  $self->{update}  = $args{update} || 0;
  $self->{timeout} = $args{timeout} || 3;
  $self->{metas}   = Utils::get_default_meta($self->{default});
  $self->{sockfile}= $args{sockfile} || '/var/log/telegraf/telegraf.sock';
  $self->{consul_fail} = 0;

  return undef unless defined $self->{servers}->[0];
  return bless $self, $class;
}

sub get_socket {
  my $self = shift;
  my $sockfile = $self->{sockfile};
  my $fail = 0;

  return undef unless -e $sockfile;
  my $socket = IO::Socket::UNIX->new(
    Peer  => "$sockfile",
    Type  => SOCK_STREAM,
    Timeout  => 3,
  ) || $fail++;

  if ($fail > 0) {
    Utils::time_print("get socket error for: $sockfile");
  }
  return $socket;
}

sub _get_alive_server {
  my $server = shift;
  my @servers;
  foreach my $k (@$server) {
    my ($host, $port) = split(/:/, $k, 2);

    next unless (defined $host && defined $port);
    next if $port !~ /^\d+$/;

    if (Utils::is_tcp_port_open($host, $port)) {
      push @servers, "$k";
    } 
    else {
      Utils::time_print("$host:$port is not alive, skip..");
    }
  }

  return \@servers;
}

sub get_graphite_server {
  my $self = shift;
  my $conf = $self->{conf};

  my $err;
  open my $fh, '<', $conf or $err = "$!";

  unless(defined $fh) {
    Utils::time_print("open $conf error: $err");
    return undef;
  };

  my @servers;
  my $seen = 0;
  while(<$fh>) {
    chomp;
    if (m/\[\[outputs.graphite\]\]/i) {
      $seen = 1;
      next;
    }

    last if ($seen == 1 and m/.*\[\[.+?\]\]/i);
    if ($seen == 1) {
      if (m/^\s*servers\s*=\s*\[(.+?)\]/i) {
        my $s = $1;
        if (defined $s) {
          $s =~ s/"//g;
          @servers = split(/,\s*/, $s);

          last;
        }
      }
    }
  }

  return \@servers;
}

sub get_telegraf_list {
  my $self = shift;

  my %cnf_list;
  $cnf_list{$self->{conf}} = Utils::parsecfg_file($self->{conf});

  if (-d $self->{confd}) {
    my @lists = Utils::get_confd_list($self->{confd});
    foreach my $k (@lists) {
      $cnf_list{$k} = Utils::parsecfg_file($k);
    }
  }

  return %cnf_list;
}

sub get_telegraf_list_interval {
  my $self = shift;

  my %results;
  my %conf_list = $self->get_telegraf_list();
  foreach my $k (keys %conf_list) {
    foreach my $v (keys %{$conf_list{$k}}) {
      $results{$k}{$v} = $conf_list{$k}{$v}->{interval} || '"30s"';
    }
  }

  my %res;
  foreach my $k (keys %results) {
    foreach my $i (keys %{$results{$k}}) {
      next if $i eq '';
      $res{$i}{$k}->{interval} = $results{$k}{$i};
    }
  }

  return \%res;
}

sub get_telegraf_conf_content {
  my $self = shift;
  my $conf = shift;
  my %cnf_list;

  $cnf_list{$conf} = Utils::splitcfg_file($conf);

  my %results;
  foreach my $k (keys %cnf_list) {
    $results{_fields_}{$k} = $cnf_list{$k}{fields};
    foreach my $i (keys %{$cnf_list{$k}{sections}}) {
      next if $i eq '';
      $results{_section_}{$i}{$k}->{content} = $cnf_list{$k}{sections}{$i}{content};
    }
  }

  return \%results;
}

sub _replace_interval {
  my $content  = shift;
  my $interval = shift;
  $interval =~ s/(?:"|'|s)//g;
  $interval .= "s";

  my $results = "  interval = \"$interval\"" . "\n";

  my @lines = split(/(?:\015{1,2}\012|\015|\012)/, $content);

  foreach my $k (@lines) {
    chomp($k);
    next if $k =~ /^\s*interval\s*=/;

    $results .= "$k\n";
  }

  return $results;
}

sub safe_write {
  my $self    = shift;
  my $source  = shift;
  my $content = shift;

  Utils::create_dir_if($self->{bakdir});

  my $file  = basename($source);
  my $dest  = $self->{bakdir} . "/" . "$file";
  my $is_cp = 0;

  unless ($self->{update} == 1) {
    Utils::time_print("ignore safe write as not in update mode!");
    return 1;
  }

  # backup before generate new conf
  if (-e $source) {
    if (Utils::file_crc32($source) eq Utils::string_crc32($content)) {
      Utils::time_print("skip to write as there is no change in the content and source file!");
      return 0;
    }

    if (copy($source, $dest)) {
      Utils::time_print("copy $source to $dest ok!");
      $is_cp = 1;
    }
    else {
      Utils::time_print("copy $source to $dest error!");
    }
  }

  # write to $source
  if (Utils::create_cnf_if($source, $content, 1)) {
    Utils::time_print("write to $source ok!");
  }
  else {
    Utils::time_print("write to $source error!");
    if ($is_cp) {
      copy($dest, $source) or Utils::time_print("recovery from $dest error!");
    }
    return 0;
  }

  return 1;
}

sub safe_delete {
  my $self = shift;
  my $conf = shift;

  unless ($self->{update} == 1) {
    Utils::time_print("ignore safe delete as not in update mode!");
    return 1;
  }

  return 1 unless -e $conf;

  my $file = basename($conf);
  my $dest = $self->{bakdir} . "/" . "$file";

  my $del_status = 0;
  if (copy($conf, $dest)) {
    Utils::time_print("copy delete file $conf to $dest");
    $del_status = unlink $conf;
  }

  return $del_status; 
}

sub get_telegraf_content {
  my $self = shift;

  my %cnf_list;
  $cnf_list{$self->{conf}} = Utils::splitcfg_file($self->{conf});

  if (-d $self->{confd}) {
    my @lists = Utils::get_confd_list($self->{confd});
    foreach my $k (@lists) {
      $cnf_list{$k} = Utils::splitcfg_file($k);
    }
  }

  my %results;
  foreach my $k (keys %cnf_list) {
    $results{_fields_}{$k} = $cnf_list{$k}{fields};
    foreach my $i (keys %{$cnf_list{$k}{sections}}) {
      next if $i eq '';
      $results{_section_}{$i}{$k}->{content} = $cnf_list{$k}{sections}{$i}{content};
    }
  }

  return \%results;
}

sub _make_line {
  my ($meta, $key, $value) = @_;

  # value must be integer
  unless ($value =~ /^\d+$/) {
    Utils::time_print("_make_line: value must be integer");
    return undef;
  }

  my $line = "$key;";
  foreach my $k (qw(dc mark team host ip)) {
    my $v = $meta->{$k} || 'NULL';

    $line .= "$k=$v";
    $line .= ";" if $k ne 'ip';
  }

  $line .= " $value";

  return $line;
}

sub send_custom_to_graphite {
  my $self   = shift;
  my $metric = shift;
  my $value  = shift;

  my $metas = $self->{metas};
  my $line  = _make_line($metas, $metric, $value);
  return 0 unless defined $line;
  
  my $socket = $self->get_socket();
  if (defined $socket) {
    print $socket "$line";
  }

  return 1;
}

sub _parse_consulkv {
  my $msg = shift;

  my $json_out;
  eval {
    $json_out = JSONTiny::decode_json($msg);
  };
  if ($@) {
    $json_out = JSONTiny::decode_json('{"Status": 599, "Flags": 0, "Value": ""}');
  }

  return $json_out;
}

sub make_consul_request {
  my $self   = shift;
  my $server = shift;
  my $key    = shift;

  $key =~ s/^\/// if $key =~ /^\//;
  my $token   = $self->{token};
  my $timeout = $self->{timeout} || 3;
  $timeout    .= "s" if $timeout =~ /^\d+$/;

  my $scheme  = lc($self->{scheme});
  my $command = "consul-kv -server $server -token $token -key $key -meta -timeout $timeout";

  $command .= " -tls" if $scheme eq 'https';
  my $response = _parse_consulkv(Utils::exec_cmd_return("$command"));
  my %result = (create_time => 0, value => undef);

  $result{status} = $response->{Status} || -99;
  unless (grep(/^$result{status}$/, qw(200 403 404))) {
    Utils::time_print("consul request is not ok, unkown error, status code: $result{status}");
  }

  if ($result{status} == 599) {
    $self->{consul_fail} += 1;
  }

  if ($result{status} == 200) {
    $result{create_time} = $response->{Flags} || 0;
    $result{value}       = defined $response->{Value} ? decode_base64($response->{Value}) : undef;
  }
  return \%result;
}

sub get_consul_key {
  my $self = shift;
  my $meta  = shift;

  my $tag = $meta->{tag};
  my $is_input = $meta->{is_input} || 0;

  my $metas = $self->{metas};
  my $team  = $metas->{team} || 'NULL';
  my $mark  = $metas->{mark} || 'NULL';
  my $ip    = $metas->{ip} || 'NULL';

  my @keys = ();
  return @keys if (!defined($team) || !defined($mark) || !defined($ip));

  if ($tag eq 'discover') {
    push @keys, "telegraf/$team/$mark/discover/$ip";
    push @keys, "telegraf/$team/$mark/discover/default";
  }

  if ($tag eq 'interval') {
    push @keys, "telegraf/$team/$mark/interval/$ip";
    push @keys, "telegraf/$team/$mark/interval/default";
  }

  if ($tag eq 'timechange') {
    push @keys, "telegraf/$team/$mark/timechange/$ip";
    push @keys, "telegraf/$team/$mark/timechange/default";
  }

  if ($tag eq 'inputs') {
    push @keys, "telegraf/$team/$mark/inputs/_lists_";
  }

  if ($is_input) {
    push @keys, "telegraf/$team/$mark/inputs/$tag/$ip";
    push @keys, "telegraf/$team/$mark/inputs/$tag/default";
  }

  return @keys;
}

sub get_key_from_consul {
  my $self    = shift;
  my $meta    = shift;
  my $minute  = shift || 0;

  my ($key1, $key2) = $self->get_consul_key($meta);
  return undef if (!defined($key1) && !defined($key2));

  my $result = undef;;
  foreach my $s (shuffle(@{$self->{servers}})) {
    $result = $self->make_consul_request($s, $key1);
    last if defined $result->{value};

    if (defined $key2) {
      $result = $self->make_consul_request($s, $key2);
      last if defined $result->{value};
    }
  }

  if ($result->{create_time} > 0) {
      # return undef if current greater than expire minutes
      if ( time() > (($minute*60) + $result->{create_time}) ) {
        $result->{value} = undef;
      }
  }

  return $result;
}

sub write_interval_conf {
  my $self = shift;
  my $key  = shift;
  my $conf = shift;
  my $interval = shift;
  my $diff     = shift;

  my %seen;
  my $content = "# generate by telegraf-discover\n";
  foreach my $t (@{$diff->{_fields_}{$conf}}) {
    $seen{$t}++;
    next if $seen{$t} > 1;
    foreach my $c (@{$diff->{_section_}{$t}{$conf}{content}}) {
      $content .= "[$t]" . "\n";
      if ($t eq $key) {
        $content .= _replace_interval($c, $interval) . "\n";
      }
      else {
        $content .= "$c" . "\n";
      }
    }
  }

  return $self->safe_write($conf, $content);
}

sub gen_new_interval_conf {
  my $self = shift;

  my $interval_default = $self->get_telegraf_list_interval();
  my $interval_result  = $self->get_key_from_consul({ tag => 'interval' }, 2);
  my $interval_consul  = Utils::parsecfg($interval_result->{value});

  my $counter = 0;
  foreach my $k (keys %{$interval_consul}) {
    foreach my $f (keys %{$interval_default->{$k}}) {
      if ($interval_consul->{$k}->{interval} ne $interval_default->{$k}->{$f}{interval}) {
        Utils::time_print("generate interval conf: $k, $f - $interval_consul->{$k}->{interval}");
        my $diff = $self->get_telegraf_conf_content($f);
        $counter++ if $self->write_interval_conf($k, $f, $interval_consul->{$k}->{interval}, $diff);
      }
    }
  }

  return $counter;
}

sub get_input_list_from_consul {
  my $self   = shift;

  my $result  = $self->get_key_from_consul({ tag => 'inputs' }, 0);
  my $value   = $result->{value};
  return undef unless defined $value;

  my @ignore_lists = qw(cpu disk diskio kernel mem processes swap
                        system conntrack internal interrupts
                        kernel_vmstat linux_sysctl_fs net netstat);

  $value =~ s/\x{22}|\x{27}//g;
  my @list;
  foreach my $k (split(/,\s*/, $value)) {
    next unless defined $k;
    if (grep(/^$k$/, @ignore_lists)) {
      Utils::time_print("ignore input $k which in telegraf.conf");
      next;
    }
    push @list, $k;
  }

  return @list;
}

sub _ip_ignore_handle {
  my $ignore = shift;
  return undef unless defined $ignore;

  $ignore =~ s/\x{22}|\x{27}//g;
  my %ignore_hash;
  foreach my $k (split(/,\s*/, $ignore)) {
    my ($ip, $is_del) = split(/\s*->\s*/, $k);
    $ignore_hash{$ip}{ip} = $ip;
    $ignore_hash{$ip}{is_del} = $is_del || 0;
  }

  return \%ignore_hash;
}

sub meta_ip_ignores {
  my $self  = shift;
  my $tag   = shift;

  my $metas = $self->{metas};
  my $team  = $metas->{team} || 'NULL';
  my $mark  = $metas->{mark} || 'NULL';
  my $ip    = $metas->{ip} || 'NULL';

  my $ignore_key = "telegraf/$team/$mark/inputs/$tag/ip_ignores";
  my $ignore_ref;
  foreach my $s (shuffle(@{$self->{servers}})) {
    $ignore_ref = $self->make_consul_request($s, $ignore_key);
    last if defined $ignore_ref->{value};
  }

  my $handle_hash = _ip_ignore_handle($ignore_ref->{value});
  return $handle_hash->{$ip};
}

sub gen_new_inputs_conf {
  my $self = shift;
  my @inputs = $self->get_input_list_from_consul();

  my $counter = 0;
  foreach my $k (@inputs) {
    next unless defined $k;
    my $conf   = $self->{confd} . "/" . "$k" . "-auto.conf";
    my $result = $self->get_key_from_consul({ tag => $k, is_input => 1}, 2);
    my $value  = $result->{value};
    next unless defined $value;

    my $ignore_meta = $self->meta_ip_ignores($k);
    if (defined $ignore_meta->{ip}) {
      if ($ignore_meta->{is_del} == 1) {
        Utils::time_print("will delete $conf as ip_ignores");
        $counter++ if $self->safe_delete($conf);
      }
      else {
        next;
      }
    }
    else {
      Utils::time_print("generate input conf: $conf");
      $counter++ if $self->safe_write($conf, $value);
    }
  }

  return $counter;
}

sub _replace_agent {
  my $content = shift;
  my $diff    = shift;

  my $time_change = $diff->{time_change};
  my $time_server = $diff->{time_server};

  my $result = '';
  my @lines = split(/(?:\015{1,2}\012|\015|\012)/, $content);
  foreach my $k (@lines) {
    chomp($k);
    next if $k =~ m/(?:time_change|time_server)/i;
    $result .= "$k\n";
  }
  $result .= "  time_change = $time_change\n";
  if ($time_change eq 'true') {
    $result .= "  time_server = \"$time_server\"\n";
  }

  return $result;
}

sub _is_timechange {
  my $conf  = shift;
  my $diff  = shift;

  my $agent_cnf = Utils::parsecfg_file($conf);
  my $time_change = $agent_cnf->{agent}->{time_change} || 'false';
  my $time_server = $agent_cnf->{agent}->{time_server} || '';

  if ($time_change eq $diff->{time_change}
      && $time_server eq $diff->{time_server}) {
    return 0;
  }

  return 1;
}

sub write_timechange_conf {
  my $self  = shift;
  my $diff  = shift;

  return 0 unless _is_timechange($self->{conf}, $diff);

  my %seen;
  my $agent_content = Utils::splitcfg_file($self->{conf});

  my $content = "# generate by telegraf-discover\n";
  foreach my $k (@{$agent_content->{fields}}) {
    $seen{$k}++;
    next if $seen{$k} > 1;

    foreach my $c (@{$agent_content->{sections}{$k}{content}}) {
      $content .= "[$k]" . "\n";
      
      if ($k eq 'agent') {
        $content .= _replace_agent($c, $diff) . "\n";
      }
      else {
        $content .= "$c\n";
      }
    }
  }

  return $self->safe_write($self->{conf}, $content);
}

sub _parse_timechange {
  my $info = shift;

  my %lists;
  my $agent_time = Utils::parsecfg($info);

  return undef unless defined $agent_time->{agent}->{time_server};

  $lists{time_change} = $agent_time->{agent}->{time_change} || 'false';
  $lists{time_server} = $agent_time->{agent}->{time_server};
  $lists{time_change} =~ s/\x{22}|\x{27}//g;
  $lists{time_server} =~ s/\x{22}|\x{27}//g;

  return \%lists;
}

sub gen_new_timechange_conf {
  my $self = shift;

  my $timeinfo = _parse_timechange($self->get_key_from_consul({tag => 'timechange'}, 2)->{value});
  my $counter = 0;

  if (defined $timeinfo) {
    $counter++ if $self->write_timechange_conf($timeinfo);
  }

  return $counter;
}

sub make_consul_discover {
  my $self = shift;

  my $counter = 0;

  Utils::time_print("discover consul for interval.");
  $counter += $self->gen_new_interval_conf();

  if ($self->{consul_fail}) {
    Utils::time_print("consul request error, skip the other check...");
  }
  else {
    Utils::time_print("discover consul for inputs.");
    $counter += $self->gen_new_inputs_conf();
   
    Utils::time_print("discover consul for timechange.");
    $counter += $self->gen_new_timechange_conf();
  }

  return $counter;
}

1;

# ########################################################
# Disconf packages
# ########################################################
package Disconf;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);  # Avoids regex performance penalty
use Utils;

sub new {
  my ($class, %args) = @_;
  my $self = {};
  $self->{update} = $args{update} || 0;
  $self->{force}  = $args{force} || 0;
  return bless $self, $class;
}

sub is_support {
  my $self = shift;
  my $type = shift;

  my @lists = qw(memcached redis pika mysql mongodb postgresql dns_query megacli iptables haproxy);
  foreach my $k (@lists) {
    return 1 if $k eq $type;
  }
  return 0;
}

sub is_update {
  my $self = shift;
  if ($self->{update}) {
    return 1;
  }
  return 0;
}

sub is_in_list {
  my $self = shift;
  my $ref  = shift;
  my $port = shift;

  foreach my $k (keys %$ref) {
    return 1 if $ref->{$k} == $port;
  }
  return 0;
}

sub is_telegraf_alive {
  my $self = shift;

  my $pid  = Utils::exec_cmd_return("pidof telegraf");
  return 0 if length($pid) == 0;

  my $is_alive = kill 0, $pid;

  return $is_alive;
}

sub _get_file_mtime {
  my $file = shift;

  return 0 unless -e $file;
  my $mtime = (stat($file))[9];

  return $mtime;
}

sub is_telegraf_conf_change {
  my $self = shift;
  my $path = shift;

  my $ts_now    = time;
  my @cnfs      = Utils::get_confd_list($path);
  foreach my $k (@cnfs) {
    next if $k =~ /discover/i;

    my $ft = _get_file_mtime($k);
    if (abs($ft - $ts_now) < 90) {
      return 1;
    }
  }

  return 0;
}

sub _get_host_ip {
  my $host = shift;
  my $ip = $host;

  if ($host =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) {
    $ip = $host;
  }
  else {
    use Socket;
    my $temp = gethostbyname($host);
    if (defined $temp) {
      $ip = inet_ntoa($temp);
    }
    else {
      $ip = $host;
    }
  }

  return $ip;
}

sub is_graphite_connection_abnormal {
  my $self = shift;
  my $file = shift;

  my @servers = Utils::get_conf_servers("outputs.graphite", $file);
  my $n = @servers + 0;
  return 1 if $n == 0;

  my $res = Utils::exec_cmd_return("netstat -ntp");
  return 1 if $res =~ /^Err/;

  my $m = 0;
  foreach my $k (@servers) {
    my ($host, $port) = split(/:/, $k);
    my $ip = _get_host_ip($host);
    if ($res =~ /$ip:$port\s*ESTABLISHED/i) {
      $m++
    }
  }

  if ($n == $m) {
    return 0;
  }

  return 1;
}

sub get_server_list {
  my $self = shift;

  # we should convert programname to support type
  my %maps = (
    "memcached"    => "memcached",
    "redis-server" => "redis",
    "mongod"       => "mongodb",
    "mysqld"       => "mysql",
    "pika"         => "pika",
    "postgres"     => "postgresql",
    "postmaster"   => "postgresql",
    "haproxy"      => "haproxy",
  );

  # full lists
  my %results;

  # listen port lists
  my %listens;
  my $res = Utils::exec_cmd_return("netstat -tnlp");
  return undef if $res =~ /^Err/;

  foreach my $k (split(/\n/, $res)) {
    # filter non-db program
    next unless $k =~ m/(?:mysqld|memcached|redis-server|mongod|pika|postgres|postmaster|haproxy)/i;
    my @items = split(/\s+/, $k, 7);

    local $_ = "$items[3] $items[-1]";
    if (m#.+:(\d+)\s+(\d+)/(.+?)(?:\s+|$)#i) {
      my $t = $maps{$3};
      next unless defined $t;
      $listens{$t}->{$2} = undef unless defined $listens{$t};
      next if (defined $listens{$t}->{$2} && $listens{$t}->{$2} =~ /\b$1\b/i);
      unless (defined $listens{$t}->{$2}) {
        $listens{$t}->{$2} = $1;
      }
      if (defined $listens{$t}->{$2} 
           && $listens{$t}->{$2} > $1) {
        $listens{$t}->{$2} = $1;
      }
    }
  }

  $results{listen} = \%listens;

  # non-listen lists
  $results{non_listen}->{dns_query} = {};
  $results{one_enable}->{megacli} = {};
  $results{one_enable}->{iptables} = {};

  return \%results;
}

sub disc_iptables {
  my $self = shift;
  my $secs = shift;

  my $temp = <<'TEMP_END';
# Gather packets and bytes throughput from iptables
[[inputs.iptables]]
  ## iptables require root access on most systems.
  ## Setting 'use_sudo' to true will make use of sudo to run iptables.
  ## Users must configure sudo to allow telegraf user to run iptables with no password.
  ## iptables can be restricted to list command "iptables -nvL" or "iptables -S".
  use_sudo = true
  ## Setting 'use_rule' to true to get ruleid result. default is true
  use_rule = false
  ## Setting 'use_lock' to true runs iptables with the "-w" option.
  ## Adjust your sudo settings appropriately if using this option ("iptables -w 5 -nvl")
  use_lock = false
  ## Define an alternate executable, such as "ip6tables". Default is "iptables".
  binary = "iptables"
  ## defines the table to monitor:
  table = "filter"
  ## defines the chains to monitor.
  ## NOTE: iptables rules without a comment will not be monitored when use_rule is true.
  ## Read the plugin documentation for more information.
  chains = [ "INPUT", "FORWARD" ]
TEMP_END

  return $temp;
}

sub disc_megacli {
  my $self = shift;
  my $secs = shift;

  my $temp = <<'TEMP_END';
# Read megacli's basic status information
# This canbe used in physical server.
[[inputs.megacli]]
  interval = "3600s"
  ## Optionally specify the path to the megacli executable
  path_megacli = "/usr/bin/MegaCli"

  ## Gather info of the following type:
  ## raid, disk, bbu
  ## default is gather all of the three type
  gather_type = ['disk', 'raid', 'bbu']

  ## On most platforms used cli utilities requires root access.
  ## Setting 'use_sudo' to true will make use of sudo to run MegaCli.
  ## Sudo must be configured to allow the telegraf user to run MegaCli
  ## without a password.
  use_sudo = true

  ## Timeout for the cli command to complete.
  timeout = "5s"
TEMP_END

  return $temp;
}

sub _parse_resolv {
  my $is_quote = shift;
  my $rs = "/etc/resolv.conf";

  return undef unless -r $rs;

  open my $fh, '<', $rs
     or return undef;

  my @servers;
  while(<$fh>) {
    next unless /^\s*nameserver\s+/i;
    my ($ser) = ($_ =~ /^\s*nameserver\s+(.+?)\s*$/i);
    $ser = '"' . $ser . '"' if defined $is_quote;
    push @servers, $ser if defined $ser;
  }

  return \@servers;
}

sub _replace_dns_query {
  my $temp = shift;
  my $secs = shift;

  my $servers = _parse_resolv(1);

  return undef if @$servers == 0;
  return undef unless Utils::is_tcp_port_open("wwww.baidu.com", 443);

  my $out = join(", ", @$servers);
  $temp =~ s/'''instances'''/$out/g;

  $secs->{domains} ||= 'www.baidu.com';
  my @domains = split(/,\s*/, $secs->{domains});
  my $ins_domains = join(", ", map { chomp; '"' . Utils::remove_psquote($_) . '"' } @domains);
  $temp =~ s/'''domains'''/$ins_domains/g;

  return $temp;
}

sub disc_dns_query {
  my $self = shift;
  my $secs = shift;

  my $temp = <<'TEMP_END';
# Query given DNS server and gives statistics
[[inputs.dns_query]]
  ## servers to query
  servers = ['''instances''']

  ## Network is the network protocol name.
  network = "udp"

  ## Domains or subdomains to query.
  domains = ['''domains''']

  ## Query record type.
  ## Possible values: A, AAAA, CNAME, MX, NS, PTR, TXT, SOA, SPF, SRV.
  record_type = "A"

  ## Dns server port.
  port = 53

  ## Query timeout in seconds.
  timeout = 2
TEMP_END

  return _replace_dns_query($temp, $secs);
}

sub _replace_memcached {
  my $temp  = shift;
  my $items = shift;

  my @servers;
  foreach my $k (@$items) {
    my $port = $k->{port};
    push @servers, '"' . '$IP' . ":" . $port . '"';
  }

  return undef if @servers == 0;

  my $out = join(", ", @servers);
  $temp =~ s/'''instances'''/$out/g;

  return $temp;
}

sub disc_memcached {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read metrics from one or many memcached servers
[[inputs.memcached]]
  ## An array of address to gather stats about. Specify an ip on hostname
  ## with optional port. ie localhost, 10.0.0.1:11211, etc.
  servers = ['''instances''']
  # unix_sockets = ["/var/run/memcached.sock"]
TEMP_END

  return _replace_memcached($temp, $items);
}

sub _replace_mysql {
  my $temp  = shift;
  my $items = shift;

  my @servers;
  foreach my $k (@$items) {
    my $port = $k->{port};
    my $user = $k->{user};
    my $pass = $k->{pass};

    next if (!(defined $user) or !(defined $pass));

    my $dsn  = '"'
             . "$user" . ":" . "$pass"
             . '@' . "tcp"
             . "(" . '$IP' . ":" . "$port" . ")"
             . "/information_schema?tls=false"
             . '"';
    push @servers, $dsn;
  }
  
  return undef if @servers == 0;

  my $out = join(", ", @servers);
  $temp =~ s/'''instances'''/$out/g;

  return $temp;
}

sub disc_mysql {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read metrics from one or many mysql servers
[[inputs.mysql]]
  ## specify servers via a url matching:
  ##  [username[:password]@][protocol[(address)]]/[?tls=[true|false|skip-verify|custom]]
  ##  see https://github.com/go-sql-driver/mysql#dsn-data-source-name
  ##  e.g.
  ##    servers = ["user:passwd@tcp(127.0.0.1:3306)/?tls=false"]
  ##    servers = ["user@tcp(127.0.0.1:3306)/?tls=false"]
  #
  ## If no servers are specified, then localhost is used as the host.
  servers = ['''instances''']

  ## Selects the metric output format.
  ##
  ## This option exists to maintain backwards compatibility, if you have
  ## existing metrics do not set or change this value until you are ready to
  ## migrate to the new format.
  ##
  ## If you do not have existing metrics from this plugin set to the latest
  ## version.
  ##
  ## Telegraf >=1.6: metric_version = 2
  ##           <1.6: metric_version = 1 (or unset)
  metric_version = 2

  ## we'll ignore to log error message if gather error
  gather_error_quiet = true

  ## if the list is empty, then metrics are gathered from all database tables
  # table_schema_databases = []

  ## gather metrics from INFORMATION_SCHEMA.TABLES for databases provided above list
  # gather_table_schema = false

  ## gather thread state counts from INFORMATION_SCHEMA.PROCESSLIST
  gather_process_list = true

  ## gather user statistics from INFORMATION_SCHEMA.USER_STATISTICS
  gather_user_statistics = true

  ## gather auto_increment columns and max values from information schema
  # gather_info_schema_auto_inc = false

  ## gather metrics from INFORMATION_SCHEMA.INNODB_METRICS
  gather_innodb_metrics = true

  ## gather metrics from SHOW SLAVE STATUS command output
  gather_slave_status = true

  ## gather metrics from SHOW BINARY LOGS command output
  gather_binary_logs = true

  ## gather metrics from PERFORMANCE_SCHEMA.GLOBAL_VARIABLES
  gather_global_variables = true

  ## gather metrics from PERFORMANCE_SCHEMA.TABLE_IO_WAITS_SUMMARY_BY_TABLE
  gather_table_io_waits = false

  ## gather metrics from PERFORMANCE_SCHEMA.TABLE_LOCK_WAITS
  gather_table_lock_waits = false

  ## gather metrics from PERFORMANCE_SCHEMA.TABLE_IO_WAITS_SUMMARY_BY_INDEX_USAGE
  gather_index_io_waits = false

  ## gather metrics from PERFORMANCE_SCHEMA.EVENT_WAITS
  gather_event_waits = false

  ## gather metrics from PERFORMANCE_SCHEMA.FILE_SUMMARY_BY_EVENT_NAME
  gather_file_events_stats = false

  ## gather metrics from PERFORMANCE_SCHEMA.EVENTS_STATEMENTS_SUMMARY_BY_DIGEST
  gather_perf_events_statements = false

  ## the limits for metrics form perf_events_statements
  # perf_events_statements_digest_text_limit = 120
  # perf_events_statements_limit = 250
  # perf_events_statements_time_limit = 86400

  ## gather metrics from PERFORMANCE_SCHEMA.EVENTS_STATEMENTS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME
  # gather_perf_sum_per_acc_per_event         = false

  ## list of events to be gathered for gather_perf_sum_per_acc_per_event
  ## in case of empty list all events will be gathered
  # perf_summary_events                       = []

  ## Some queries we may want to run less often (such as SHOW GLOBAL VARIABLES)
  ##   example: interval_slow = "30m"
  interval_slow = "1m"
TEMP_END

  return _replace_mysql($temp, $items);
}

sub _replace_mongodb {
  my $temp  = shift;
  my $items = shift;

  my @servers;
  foreach my $k (@$items) {
    my $port = $k->{port};
    my $user = $k->{user};
    my $pass = $k->{pass};

    my $dsn;
    if (defined $user and defined $pass) {
      $dsn = '"'
           . "mongodb://"
           . "$user" . ":" . "$pass"
           . '@'
           . '$IP' . ":" . "$port"
           . '"';
    }
    else {
      $dsn = '"'
           . "mongodb://"
           . '$IP' . ":" . "$port"
           . '"';
    }

    push @servers, $dsn;
  }

  return undef if @servers == 0;

  my $out = join(", ", @servers);
  $temp =~ s/'''instances'''/$out/g;

  return $temp;
}

sub disc_mongodb {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read metrics from one or many MongoDB servers
[[inputs.mongodb]]
  ## An array of URLs of the form:
  ##   "mongodb://" [user ":" pass "@"] host [ ":" port]
  ## For example:
  ##   mongodb://user:auth_key@10.10.3.30:27017,
  ##   mongodb://10.10.3.33:18832,
  servers = ['''instances''']

  ## When true, collect cluster status
  ## Note that the query that counts jumbo chunks triggers a COLLSCAN, which
  ## may have an impact on performance.
  # gather_cluster_status = true

  ## When true, collect per database stats
  # gather_perdb_stats = false

  ## When true, collect per collection stats
  # gather_col_stats = false

  ## List of db where collections stats are collected
  ## If empty, all db are concerned
  # col_stats_dbs = ["local"]

  ## Optional TLS Config
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false
TEMP_END

  return _replace_mongodb($temp, $items);
}

sub _replace_redis {
  my $temp  = shift;
  my $items = shift;

  my @servers;
  foreach my $k (@$items) {
    my $port = $k->{port};
    my $pass = _pass_url_encode($k->{pass});

    my $dsn;
    if (defined $pass) {
      $dsn = '"'
           . "tcp://"
           . ":" . "$pass" . '@'
           . '$IP' . ":" . "$port"
           . '"';
    }
    else {
      $dsn = '"'
           . "tcp://"
           . '$IP' . ":" . "$port"
           . '"';
    }

    push @servers, $dsn;
  }

  return undef if @servers == 0;

  my $out = join(", ", @servers);
  $temp =~ s/'''instances'''/$out/g;

  return $temp;
}

sub disc_redis {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read metrics from one or many redis servers
[[inputs.redis]]
  ## specify servers via a url matching:
  ##  [protocol://][:password]@address[:port]
  ##  e.g.
  ##    tcp://localhost:6379
  ##    tcp://:password@192.168.99.100
  ##    unix:///var/run/redis.sock
  ##
  ## If no servers are specified, then localhost is used as the host.
  ## If no port is specified, 6379 is used
  servers = ['''instances''']

  ## Optional. Specify redis commands to retrieve values
  # [[inputs.redis.commands]]
  # command = ["get", "sample-key"]
  # field = "sample-key-value"
  # type = "string"

  ## specify server password
  # password = "s#cr@t%"

  ## Optional TLS Config
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = true
TEMP_END

  return _replace_redis($temp, $items);
}

sub _replace_pika {
  my $temp  = shift;
  my $items = shift;

  my @servers;
  foreach my $k (@$items) {
    my $port = $k->{port};
    my $pass = $k->{pass};

    my $dsn;
    if (defined $pass) {
      $dsn = '"'
           . "tcp://"
           . ":" . "$pass" . '@'
           . '$IP' . ":" . "$port"
           . '"';
    }
    else {
      $dsn = '"'
           . "tcp://"
           . '$IP' . ":" . "$port"
           . '"';
    }

    push @servers, $dsn;
  }

  return undef if @servers == 0;

  my $out = join(", ", @servers);
  $temp =~ s/'''instances'''/$out/g;

  return $temp;
}

sub disc_pika {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read pika's basic status information
[[inputs.pika]]
  ## specify servers via a url matching:
  ##  [protocol://][:password]@address[:port]
  ##  e.g.
  ##    tcp://localhost:9221
  ##    tcp://:password@192.168.99.100
  ##
  ## If no servers are specified, then localhost is used as the host.
  ## If no port is specified, 9221 is used
  servers = ['''instances''']
  ## Optional. Specify redis commands to retrieve values
  # [[inputs.pika.commands]]
  # command = ["get", "sample-key"]
  # field = "sample-key-value"
  # type = "string"

  ## specify server password
  # password = "s#cr@t%"

  ## Optional TLS Config
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = true
TEMP_END

  return _replace_pika($temp, $items);
}

sub _replace_postgresql {
  my $temp  = shift;
  my $items = shift;

  my @servers;
  foreach my $k (@$items) {
    my $port = $k->{port};
    my $user = $k->{user};
    my $pass = $k->{pass};
    my $host = $k->{is_local} > 0
             ? 'localhost'
             : '$IP';

    next unless defined $user;

    my $dsn;
    if (defined $pass) {
      $dsn = '"'
           . "postgres://" . "$user"
           . ":" . "$pass" . '@'
           . "$host" . ":" . "$port"
           . "/postgres?sslmode=disable"
           . '"';
    }
    else {
      $dsn = '"'
           . "postgres://" . "$user" . "@"
           . "$host" . ":" . "$port"
           . "/postgres?sslmode=disable"
           . '"';
    }

    push @servers, $dsn;
  }

  return undef if @servers == 0;

  my $out = join(", ", @servers);
  $temp =~ s/'''instances'''/$out/g;

  if ($items->[0]->{is_local} > 0) {
    $temp =~ s/'''is_local'''//g;
  }
  else {
    $temp =~ s/'''is_local'''/# /g;
  }

  return $temp;
}

sub disc_postgresql {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read metrics from one or many postgresql servers
[[inputs.postgresql_extensible]]
  ## specify address via a url matching:
  ##   postgres://[pqgotest[:password]]@localhost[/dbname]\
  ##       ?sslmode=[disable|verify-ca|verify-full]
  ## or a simple string:
  ##   host=localhost user=pqgotest password=... sslmode=... dbname=app_production
  ##
  ## All connection parameters are optional.
  ##
  servers = ['''instances''']

  ## A custom name for the database that will be used as the "server" tag in the
  ## measurement output, and we'll add port to the outputaddress by default.
  ## If not specified, the connection host and port are used.
  '''is_local'''outputaddress = '$IP'

  ## connection configuration.
  ## maxlifetime - specify the maximum lifetime of a connection.
  ## default is forever (0s)
  max_lifetime = "0s"

  ## A  list of databases to explicitly ignore.  If not specified, metrics for all
  ## databases are gathered.  Do NOT use with the 'databases' option.
  ignored_databases = ["postgres", "template0", "template1"]

  ## Define the toml config where the sql queries are stored
  ## Define the toml config where the sql queries are stored
  ## New queries can be added, if the withdbname is set to true and there is no
  ## databases defined in the 'databases field', the sql query is ended by a
  ## 'is not null' in order to make the query succeed.

  [[inputs.postgresql_extensible.query]]
    sqlquery="SELECT * FROM pg_stat_database WHERE datname"
    version=901
    withignoredbname=true
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="SELECT * FROM pg_stat_bgwriter"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="""
      select
        case when setting = 'on' then 1 when setting = 'off' then 0 else -1 end as autovacuum
      from pg_settings
      where name='autovacuum'
    """
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="select setting::INTEGER as shared_buffers from pg_settings where name = 'shared_buffers'"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="select setting::INTEGER as wal_buffers from pg_settings where name = 'wal_buffers'"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="select (setting::integer * pg_size_bytes(unit)) as max_wal_size from pg_settings where name = 'max_wal_size'"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="select setting::INTEGER as effective_cache_size from pg_settings where name = 'effective_cache_size'"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="select setting::INTEGER as work_mem from pg_settings where name = 'work_mem'"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="select setting::INTEGER as max_connections from pg_settings where name = 'max_connections'"
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="""
       SELECT substring(version(), 12, 6) as version,
              round(extract(epoch from current_timestamp - pg_postmaster_start_time())) as uptime,
              case
                when pg_is_in_recovery() = 't' then 'slave'
                when pg_is_in_recovery() = 'f' and (select char_length(application_name) from pg_stat_replication) > 0 then 'master'
                when (select char_length(application_name) from pg_stat_replication) is null then 'standby'
              end as role
    """
    version=901
    withignoredbname=false
    tagvalue="version,role"

  [[inputs.postgresql_extensible.query]]
    sqlquery="""
      SELECT application_name, client_addr,
          (case state when 'stopping' then 0 when 'startup' then 1 when 'catchup' then 2 when 'streaming' then 3 when 'backup' then 4 else 9 end) AS repl_state,
          (case pg_is_in_recovery() when 't' then null else pg_xlog_location_diff(pg_current_xlog_location(), replay_location)::float end) AS pg_xlog_location_diff
      FROM pg_stat_replication
    """
    version=901
    withignoredbname=false
    tagvalue="application_name,client_addr"

  [[inputs.postgresql_extensible.query]]
    sqlquery="""
      SELECT
        CASE WHEN pg_is_in_recovery() = 't' THEN
           CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0 ELSE EXTRACT (EPOCH FROM now() - pg_last_xact_replay_timestamp()) END
        END AS lag
    """
    version=901
    withignoredbname=false
    tagvalue=""

  [[inputs.postgresql_extensible.query]]
    sqlquery="""
        SELECT pg_database.datname as db, tmp.mode as lock_mode, COALESCE(count,0) as lock_count
         FROM
        (
            VALUES ('accesssharelock'),
                   ('rowsharelock'),
                   ('rowexclusivelock'),
                   ('shareupdateexclusivelock'),
                   ('sharelock'),
                   ('sharerowexclusivelock'),
                   ('exclusivelock'),
                   ('accessexclusivelock'),
                   ('sireadlock')
         ) AS tmp(mode) CROSS JOIN (select *, oid from pg_database where datname NOT IN ('postgres', 'template0', 'template1')) AS pg_database
         LEFT JOIN
         (SELECT database, lower(mode) AS mode,count(*) AS count
           FROM pg_locks WHERE database IS NOT NULL
           GROUP BY database, lower(mode)
         ) AS tmp2
         ON tmp.mode=tmp2.mode and pg_database.oid = tmp2.database ORDER BY 1
    """
    version=901
    withignoredbname=false
    tagvalue="db,lock_mode"

  [[inputs.postgresql_extensible.query]]
    sqlquery="""
      SELECT
        pg_database.datname as db, TRANSLATE(tmp.state, ' ()', '_') as state, COALESCE(count,0) as tx_count, COALESCE(max_tx_duration,0) as max_tx_duration
      FROM
      (
        VALUES ('active'),
           ('idle'),
           ('idle in transaction'),
           ('idle in transaction (aborted)'),
           ('fastpath function call'),
           ('disabled')
      ) AS tmp(state) CROSS JOIN (select * from pg_database where datname NOT IN ('postgres', 'template0', 'template1')) AS pg_database
      LEFT JOIN
      (
        SELECT
          datname, state, count(*) AS count,
          MAX(EXTRACT(EPOCH FROM now() - xact_start))::float AS max_tx_duration
        FROM pg_stat_activity GROUP BY datname,state) AS tmp2
          ON tmp.state = tmp2.state AND pg_database.datname = tmp2.datname;
    """
    version=901
    withignoredbname=false
    tagvalue="db,state"

TEMP_END

  return _replace_postgresql($temp, $items);
}

# ignore items, as we only use socket to monit haproxy
sub disc_haproxy {
  my $self  = shift;
  my $items = shift;

  my $temp = <<'TEMP_END';
# Read metrics of HAProxy, via socket or HTTP stats page
[[inputs.haproxy]]
  ## An array of address to gather stats about. Specify an ip on hostname
  ## with optional port. ie localhost, 10.10.3.33:1936, etc.
  ## Make sure you specify the complete path to the stats endpoint
  ## including the protocol, ie http://10.10.3.33:1936/haproxy?stats

  ## Credentials for basic HTTP authentication
  # username = "admin"
  # password = "admin"

  ## If no servers are specified, then default to 127.0.0.1:1936/haproxy?stats
  #servers = ["http://myhaproxy.com:1936/haproxy?stats"]

  ## You can also use local socket with standard wildcard globbing.
  ## Server address not starting with 'http' will be treated as a possible
  ## socket, so both examples below are valid.
  servers = ["/var/run/haproxy-lb.sock"]

  ## By default, some of the fields are renamed from what haproxy calls them.
  ## Setting this option to true results in the plugin keeping the original
  ## field names.
  # keep_field_names = false

  ## Optional TLS Config
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false
TEMP_END

  return $temp;
}

sub temp_outs {
  my $self  = shift;
  my $type  = shift;
  my $items = shift;

  my %select_func;
  if (ref($items) eq 'ARRAY') {
    %select_func = (
      'memcached' => $self->disc_memcached($items),
      'mysql'     => $self->disc_mysql($items),
      'mongodb'   => $self->disc_mongodb($items),
      'redis'     => $self->disc_redis($items),
      'pika'      => $self->disc_pika($items),
      'postgresql'=> $self->disc_postgresql($items),
      'haproxy'   => $self->disc_haproxy($items),
    );
  }

  if (ref($items) eq 'HASH') {
    $select_func{'dns_query'} = $self->disc_dns_query($items);
  }

  if (ref($items) eq '') {
    $select_func{'dns_query'} = $self->disc_dns_query();
  }

  $select_func{'megacli'}   = $self->disc_megacli();
  $select_func{'iptables'}  = $self->disc_iptables();

  return $select_func{$type};
}

sub gen_conf_for_listen {
  my $self   = shift;
  my $confd  = shift;
  my $type   = shift;
  my $res    = shift;
  my $secs   = shift;

  return undef unless $self->is_support($type);

  my @items;
  my @ports;

  my @ignore_ports = split(/,\s*/, $secs->{ignore} || '');
  foreach my $p (keys %$res) {
    my $port = $res->{$p};
    next if _is_in_array($port, \@ignore_ports);

    my $user = $secs->{user} || undef;
    my $pass = $secs->{$port} || $secs->{pass} || undef;
    $pass = undef if (defined $pass && $pass =~ m/''|""/i);
    my $is_local = $secs->{is_local} || 0;

    if ($type eq 'mysql') {
      if (!defined($user) || !defined($pass)) {
        Utils::time_print("ignore $type: $port. must set user and pass for $type");
	next;
      }
    }

    if ($type eq 'postgresql') {
      if (!defined($user)) {
        Utils::time_print("ignore $type: $port. must set user for $type");
	next;
      }
    }

    push @ports, $port;
    push @items, {port => $port, user => $user, pass => $pass, is_local => $is_local};
  }

  # create conf file
  $confd  .= "/" unless $confd =~ m|/$|i;
  my $cnf = $type eq 'postgresql'
          ? $confd . "$type" . "_extensible" . "-" . "auto" . ".conf"
          : $confd . "$type" . "-" . "auto" . ".conf";

  # get current monitor port list and compare
  my @cur_ports = _get_monitor_ports($cnf);

  # use socket file for haproxy stat report
  if ($type eq 'haproxy' && -e $cnf) {
    @cur_ports = @ports;
  }
  my $comp_diff = _diff_compare(\@ports, \@cur_ports, \@ignore_ports);

  my $counter = @{$comp_diff->{add}} + @{$comp_diff->{del}} + $self->{force};
  if ($counter > 0) {
    _diff_print($type, $comp_diff);
    if ($self->is_update()) {
      my $outs = $self->temp_outs($type, \@items);
      # force overwrite cnf file
      if (Utils::create_cnf_if($cnf, $outs, 1)) {
        Utils::time_print("generate $cnf ok.");
      }
    }
  }

  return $counter;
}

sub _parse_ports {
  my $line = shift;
  my @servers = ($line =~ m/(?:\$IP|127.0.0.1|localhost):(\d+)/gi);
  return @servers;
}

sub _get_monitor_ports {
  my $conf  = shift;
  my $fetch = _get_fetch_line($conf, "servers");

  return () unless defined $fetch;
  return _parse_ports($fetch);
}

sub _non_listen_parse_func {
  my $type = shift;

  my %select_funcs = (
    'dns_query' => _parse_resolv(), # return array hash
  );

  return $select_funcs{$type};
}

sub gen_conf_for_non_listen {
  my $self  = shift;
  my $confd = shift;
  my $type  = shift;
  my $secs  = shift;

  return 0 unless $self->is_support($type);

  my $used_servers = _non_listen_parse_func($type);
  return 0 unless defined $used_servers;

  # create conf file
  $confd .= "/" unless $confd =~ m|/$|i;
  my $cnf = $confd . "$type" . "-" . "auto" . ".conf";


  # get current server lists
  my $curr_servers = _get_monitor_servers($cnf);

  my $comp_diff = _diff_compare($used_servers, $curr_servers);
  my $counter   = @{$comp_diff->{add}} + @{$comp_diff->{del}};

  if ($type eq 'dns_query') {
    if (defined($secs->{ignore}) && $secs->{ignore} > 0) {
      Utils::time_print("ignore dns_query.");
      if (-w $cnf) {
        Utils::time_print("will delete $cnf file");
        unlink $cnf if $self->is_update();
        return 1;
      }
      return 0;
    }

    if (defined($secs->{domains})) {
      my @used_domain = map { Utils::remove_psquote($_) } split(/,\s*/, $secs->{domains});
      my $curr_domain = _get_dns_domains($cnf);
      my $comp_domain = _diff_compare(\@used_domain, $curr_domain);
      
      $counter += @{$comp_domain->{add}} + @{$comp_domain->{del}};
      _diff_print($type, $comp_domain) if $counter > 0;
    }
  }

  if ($counter > 0) {
    _diff_print($type, $comp_diff);
    if ($self->is_update()) {
      my $outs = $self->temp_outs($type, $secs);
      # force overwrite cnf file
      if (Utils::create_cnf_if($cnf, $outs, 1)) {
        Utils::time_print("generate $cnf ok.");
      }
      else {
        $counter = 0; # reset to 0
      }
    }
  }

  return $counter;
}

sub _parse_servers {
  my $fetch = shift;
  my @servers;

  my ($line) = ($fetch =~ m/=\s*\[(.+)\]\s*$/i);
  foreach my $k (split(/,\s*/, $line)) {
    $k =~ s/'|"//g;
    push @servers, $k;
  }

  return @servers;
}

sub _get_dns_domains {
  my $conf = shift;

  my $fetch = _get_fetch_line($conf, "domains");

  return () unless defined $fetch;
  my @domains = _parse_servers($fetch);

  return \@domains;
}

sub _get_monitor_servers {
  my $conf = shift;

  my $fetch = _get_fetch_line($conf, "servers");

  return () unless defined $fetch;
  my @servers = _parse_servers($fetch);

  return \@servers;
}

sub _one_enable_white {
  my $type = shift;

  return 1 if $type eq 'iptables';

  return 0;
}

sub gen_conf_for_one_enable {
  my $self  = shift;
  my $confd = shift;
  my $type  = shift;
  my $secs  = shift;

  return 0 unless $self->is_support($type);

  $confd .= "/" unless $confd =~ m|/$|i;
  my $cnf = $confd . "$type" . "-" . "auto" . ".conf";

  my $counter = 0;

  $secs->{ignore} ||= 0 if _one_enable_white($type);

  if (defined($secs->{ignore})) {
    if ($secs->{ignore} > 0) {
      if (-w $cnf) {
        Utils::time_print("ignore $type. will del $cnf");
        if ($self->is_update()) {
          unlink $cnf;
          return 1;
        }
        return 0;
      }
    }
    else {
      if (-e $cnf) {
        # Utils::time_print("already generate $cnf");
        $counter = 0;
      }
      else {
        Utils::time_print("generate $cnf");
	$counter = 1;
      }
    }
  }

  if ($counter > 0) {
    if ($self->is_update()) {
      my $outs = $self->temp_outs($type, $secs);
      # force overwrite cnf file
      if (Utils::create_cnf_if($cnf, $outs, 1)) {
        Utils::time_print("generate $cnf ok.");
      }
      else {
        $counter = 0; # reset to 0
      }
    }
  }
  return $counter;
}

sub _get_fetch_line {
  my $conf = shift;
  my $match= shift;

  return undef unless -r $conf;
  open my $fh, '<', $conf or return undef;

  my $fetch;
  while(<$fh>) {
    chomp;
    if (/^\s*$match\s*=/i) {
      $fetch = $_;
      last;
    }
  }

  close $fh;

  return $fetch;
}

sub _diff_print {
  my $type = shift;
  my $diff = shift;

  foreach my $t (keys %$diff) {
    next unless defined $diff->{$t}->[0];
    my $list = join(", ", @{$diff->{$t}});
    Utils::time_print("will $t $type:  $list")
  }
}

sub _is_in_array {
  my $port = shift;
  my $ref  = shift;

  return 0 unless defined $ref;

  foreach my $k (@$ref) {
    return 1 if $k eq $port;
  }
  return 0;
}

sub _diff_compare {
  my $r1 = shift;
  my $r2 = shift;
  my $no = shift; # ignore list

  my %diff = (
    add => [],
    del => [],
  );

  return \%diff if (!defined $r1 && !defined $r2);

  foreach my $k (@$r1) {
    next if _is_in_array($k, $no);
    push @{$diff{add}}, $k unless _is_in_array($k, $r2);
  }
  foreach my $k (@$r2) {
    push @{$diff{del}}, $k if _is_in_array($k, $no);
    push @{$diff{del}}, $k if (!_is_in_array($k, $r1) && !_is_in_array($k, $no));
  }

  return \%diff;
}

sub _pass_url_encode {
  my $pass  = shift;
  return $pass unless defined $pass;

  my %metas = (
    '%' => '%25', '`' => '%60',
    '^' => '%5e', '$' => '%24',
    '!' => '%21', '[' => '%5b',
    ']' => '%5d', '<' => '%3c',
    '>' => '%3e', '/' => '%2f',
    '?' => '%3f', '"' => '%22',
  );

  my $newpass;
  foreach my $k (split(//, $pass)) {
    my $str = $metas{$k} || $k;
    $newpass .= $str;
  }

  return $newpass;
}

1;

#######################################################################
# package JSONTiny
######################################################################
package JSONTiny;
# Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
# License: Artistic 2.0 license.
# http://www.perlfoundation.org/artistic_license_2_0

use strict;
use warnings;
use Carp 'croak';
use Exporter 'import';
use Scalar::Util 'blessed';
use Encode();
use B;

our $VERSION = '0.58';
our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);

# Literal names
# Users may override Booleans with literal 0 or 1 if desired.
our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSONTiny::_Bool' } 0, 1;

# Escaped special character map with u2028 and u2029
my %ESCAPE = (
  '"'     => '"',
  '\\'    => '\\',
  '/'     => '/',
  'b'     => "\x08",
  'f'     => "\x0c",
  'n'     => "\x0a",
  'r'     => "\x0d",
  't'     => "\x09",
  'u2028' => "\x{2028}",
  'u2029' => "\x{2029}"
);
my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;

for(0x00 .. 0x1f) {
  my $packed = pack 'C', $_;
  $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
}

sub decode_json {
  my $err = _decode(\my $value, shift);
  return defined $err ? croak $err : $value;
}

sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }

sub false () {$FALSE}  ## no critic (prototypes)

sub from_json {
  my $err = _decode(\my $value, shift, 1);
  return defined $err ? croak $err : $value;
}

sub j {
  return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
  return decode_json $_[0];
}

sub to_json { _encode_value(shift) }

sub true () {$TRUE} ## no critic (prototypes)

sub _decode {
  my $valueref = shift;

  eval {

    # Missing input
    die "Missing or empty input\n" unless length( local $_ = shift );

    # UTF-8
    $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
    die "Input is not UTF-8 encoded\n" unless defined $_;

    # Value
    $$valueref = _decode_value();

    # Leftover data
    return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
  } ? return undef : chomp $@;

  return $@;
}

sub _decode_array {
  my @array;
  until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {

    # Value
    push @array, _decode_value();

    # Separator
    redo if m/\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if m/\G[\x20\x09\x0a\x0d]*\]/gc;

    # Invalid character
    _throw('Expected comma or right square bracket while parsing array');
  }

  return \@array;
}

sub _decode_object {
  my %hash;
  until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {

    # Quote
    m/\G[\x20\x09\x0a\x0d]*"/gc
      or _throw('Expected string while parsing object');

    # Key
    my $key = _decode_string();

    # Colon
    m/\G[\x20\x09\x0a\x0d]*:/gc
      or _throw('Expected colon while parsing object');

    # Value
    $hash{$key} = _decode_value();

    # Separator
    redo if m/\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if m/\G[\x20\x09\x0a\x0d]*\}/gc;

    # Invalid character
    _throw('Expected comma or right curly bracket while parsing object');
  }

  return \%hash;
}

sub _decode_string {
  my $pos = pos;
  
  # Extract string with escaped characters
  m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
  my $str = $1;

  # Invalid character
  unless (m/\G"/gc) {
    _throw('Unexpected character or invalid escape while parsing string')
      if m/\G[\x00-\x1f\\]/;
    _throw('Unterminated string');
  }

  # Unescape popular characters
  if (index($str, '\\u') < 0) {
    $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
    return $str;
  }

  # Unescape everything else
  my $buffer = '';
  while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
    $buffer .= $1;

    # Popular character
    if ($2) { $buffer .= $ESCAPE{$2} }

    # Escaped
    else {
      my $ord = hex $3;

      # Surrogate pair
      if (($ord & 0xf800) == 0xd800) {

        # High surrogate
        ($ord & 0xfc00) == 0xd800
          or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');

        # Low surrogate
        $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
          or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');

        $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
      }

      # Character
      $buffer .= pack 'U', $ord;
    }
  }

  # The rest
  return $buffer . substr $str, pos $str, length $str;
}

sub _decode_value {

  # Leading whitespace
  m/\G[\x20\x09\x0a\x0d]*/gc;

  # String
  return _decode_string() if m/\G"/gc;

  # Object
  return _decode_object() if m/\G\{/gc;

  # Array
  return _decode_array() if m/\G\[/gc;

  # Number
  my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
  return 0 + $i if defined $i;

  # True
  return $TRUE if m/\Gtrue/gc;

  # False
  return $FALSE if m/\Gfalse/gc;

  # Null
  return undef if m/\Gnull/gc;  ## no critic (return)

  # Invalid character
  _throw('Expected string, array, object, number, boolean or null');
}

sub _encode_array {
  '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
}

sub _encode_object {
  my $object = shift;
  my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
    sort keys %$object;
  return '{' . join(',', @pairs) . '}';
}

sub _encode_string {
  my $str = shift;
  $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
  return "\"$str\"";
}

sub _encode_value {
  my $value = shift;

  # Reference
  if (my $ref = ref $value) {

    # Object
    return _encode_object($value) if $ref eq 'HASH';

    # Array
    return _encode_array($value) if $ref eq 'ARRAY';

    # True or false
    return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
    return $value  ? 'true' : 'false' if $ref eq 'JSONTiny::_Bool';

    # Blessed reference with TO_JSON method
    if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
      return _encode_value($value->$sub);
    }
  }

  # Null
  return 'null' unless defined $value;


  # Number (bitwise operators change behavior based on the internal value type)

  return $value
    if B::svref_2object(\$value)->FLAGS & (B::SVp_IOK | B::SVp_NOK)
    # filter out "upgraded" strings whose numeric form doesn't strictly match
    && 0 + $value eq $value
    # filter out inf and nan
    && $value * 0 == 0;

  # String
  return _encode_string($value);
}

sub _throw {

  # Leading whitespace
  m/\G[\x20\x09\x0a\x0d]*/gc;

  # Context
  my $context = 'Malformed JSON: ' . shift;
  if (m/\G\z/gc) { $context .= ' before end of data' }
  else {
    my @lines = split "\n", substr($_, 0, pos);
    $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
  }

  die "$context\n";
}

# Emulate boolean type
package JSONTiny::_Bool;
use overload '""' => sub { ${$_[0]} }, fallback => 1;

1;
